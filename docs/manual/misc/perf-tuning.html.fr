<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
<!--
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
              This file is generated from xml source: DO NOT EDIT
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      -->
<title>Optimisation des performances d'Apache - Serveur HTTP Apache Version 2.5</title>
<link href="../style/css/manual.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-loose-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" /><link rel="stylesheet" type="text/css" href="../style/css/prettify.css" />
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>

<link href="../images/favicon.ico" rel="shortcut icon" /></head>
<body id="manual-page"><div id="page-header">
<p class="menu"><a href="../mod/">Modules</a> | <a href="../mod/quickreference.html">Directives</a> | <a href="http://wiki.apache.org/httpd/FAQ">FAQ</a> | <a href="../glossary.html">Glossaire</a> | <a href="../sitemap.html">Plan du site</a></p>
<p class="apache">Serveur HTTP Apache Version 2.5</p>
<img alt="" src="../images/feather.png" /></div>
<div class="up"><a href="./"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">Serveur HTTP</a> &gt; <a href="http://httpd.apache.org/docs/">Documentation</a> &gt; <a href="../">Version 2.5</a> &gt; <a href="./">Documentations diverses</a></div><div id="page-content"><div id="preamble"><h1>Optimisation des performances d'Apache</h1>
<div class="toplang">
<p><span>Langues Disponibles: </span><a href="../en/misc/perf-tuning.html" hreflang="en" rel="alternate" title="English">&nbsp;en&nbsp;</a> |
<a href="../fr/misc/perf-tuning.html" title="Fran&#231;ais">&nbsp;fr&nbsp;</a> |
<a href="../ko/misc/perf-tuning.html" hreflang="ko" rel="alternate" title="Korean">&nbsp;ko&nbsp;</a> |
<a href="../tr/misc/perf-tuning.html" hreflang="tr" rel="alternate" title="T&#252;rk&#231;e">&nbsp;tr&nbsp;</a></p>
</div>


    <div class="warning"><h3>Avertissement</h3>
      <p>Ce document est en partie obsol&#232;te et son contenu peut s'av&#233;rer
      inappropri&#233;.</p>
    </div>

    <p>Apache 2.4 est un serveur web &#224; usage g&#233;n&#233;ral, con&#231;u dans un but
    d'&#233;quilibre entre souplesse, portabilit&#233; et performances. Bien que non
    con&#231;u dans le seul but d'&#233;tablir une r&#233;f&#233;rence en la mati&#232;re,
    Apache 2.4 est capable de hautes performances dans de nombreuses situations
    du monde r&#233;el.</p>

    <p>Ce
    document d&#233;crit les options qu'un administrateur de serveur peut configurer
    pour am&#233;liorer les performances d'une installation d'Apache 2.4. Certaines
    de ces options de configuration permettent au d&#233;mon httpd de mieux tirer
    parti des possibilit&#233;s du mat&#233;riel et du syst&#232;me d'exploitation, tandis
    que d'autres permettent &#224; l'administrateur de privil&#233;gier la vitesse
    par rapport aux fonctionnalit&#233;s.</p>

  </div>
<div id="quickview"><ul id="toc"><li><img alt="" src="../images/down.gif" /> <a href="#hardware">Probl&#232;mes mat&#233;riels et relatifs au syst&#232;me d'exploitation</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#runtime">Optimisation de la configuration &#224; l'ex&#233;cution</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#compiletime">Optimisation de la configuration &#224; la compilation</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#trace">Appendice : Analyse d&#233;taill&#233;e d'une trace</a></li>
</ul><h3>Voir aussi</h3><ul class="seealso"><li><a href="#comments_section">Commentaires</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="hardware" id="hardware">Probl&#232;mes mat&#233;riels et relatifs au syst&#232;me d'exploitation</a><a title="Lien permanent" href="#hardware" class="permalink">&para;</a></h2>

    

    <p>Le principal probl&#232;me mat&#233;riel qui affecte les performances du serveur
    web est la m&#233;moire vive (RAM). Un serveur web ne devrait jamais avoir &#224;
    utiliser le swap, car le swapping augmente le temps de r&#233;ponse de chaque
    requ&#234;te au del&#224; du point que les utilisateurs consid&#232;rent comme
    "trop lent". Ceci incite les utilisateurs &#224; cliquer sur "Stop", puis
    "Charger &#224; nouveau", ce qui a pour effet d'augmenter encore la charge
    du serveur. Vous pouvez, et m&#234;me devez d&#233;finir la valeur de la directive
    <code class="directive"><a href="../mod/mpm_common.html#maxrequestworkers">MaxRequestWorkers</a></code> de fa&#231;on &#224; ce que
    votre serveur ne lance pas un nombre de processus enfants tel qu'il
    commence &#224; faire du swapping. La m&#233;thode pour y parvenir est
    simple : d&#233;terminez la taille de votre processus Apache standard en
    consultant votre liste de processus &#224; l'aide d'un outil tel que
    <code>top</code>, et divisez votre quantit&#233; totale de m&#233;moire disponible
    par cette taille, tout en gardant un espace suffisant
    pour les autres processus.</p>

    <p>Hormis ce r&#233;glage relatif &#224; la m&#233;moire, le reste est trivial : le
    processeur, la carte r&#233;seau et les disques doivent &#234;tre suffisamment
    rapides, o&#249; "suffisamment rapide" doit &#234;tre d&#233;termin&#233; par
    l'exp&#233;rience.</p>

    <p>Le choix du syst&#232;me d'exploitation d&#233;pend principalement du
    contexte local. Voici cependant quelques conseils qui se sont
    g&#233;n&#233;ralement av&#233;r&#233;s utiles :</p>

    <ul>
      <li>
        <p>Ex&#233;cutez la derni&#232;re version stable et le niveau de patches le
	plus haut du syst&#232;me d'exploitation que vous avez choisi. De nombreux
	&#233;diteurs de syst&#232;mes d'exploitation ont am&#233;lior&#233; de mani&#232;re
	significative les performances de leurs piles TCP et de leurs
	biblioth&#232;ques de thread ces derni&#232;res ann&#233;es.</p>
      </li>

      <li>
        <p>Si votre syst&#232;me d'exploitation poss&#232;de un appel syst&#232;me
	<code>sendfile(2)</code>, assurez-vous d'avoir install&#233; la version
	et/ou les patches n&#233;cessaires &#224; son activation. (Pour Linux, par
	exemple, cela se traduit par Linux 2.4 ou plus. Pour les versions
	anciennes de Solaris 8, vous pouvez &#234;tre amen&#233; &#224; appliquer un patch.)
	Sur les syst&#232;mes o&#249; il est disponible, <code>sendfile</code> permet
	&#224; Apache de servir les contenus statiques plus rapidement, tout en
	induisant une charge CPU inf&#233;rieure.</p>
      </li>
    </ul>

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="runtime" id="runtime">Optimisation de la configuration &#224; l'ex&#233;cution</a><a title="Lien permanent" href="#runtime" class="permalink">&para;</a></h2>

    

    <table class="related"><tr><th>Modules Apparent&#233;s</th><th>Directives Apparent&#233;es</th></tr><tr><td><ul><li><code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code></li><li><code class="module"><a href="../mod/mpm_common.html">mpm_common</a></code></li><li><code class="module"><a href="../mod/mod_status.html">mod_status</a></code></li></ul></td><td><ul><li><code class="directive"><a href="../mod/core.html#allowoverride">AllowOverride</a></code></li><li><code class="directive"><a href="../mod/mod_dir.html#directoryindex">DirectoryIndex</a></code></li><li><code class="directive"><a href="../mod/core.html#hostnamelookups">HostnameLookups</a></code></li><li><code class="directive"><a href="../mod/core.html#enablemmap">EnableMMAP</a></code></li><li><code class="directive"><a href="../mod/core.html#enablesendfile">EnableSendfile</a></code></li><li><code class="directive"><a href="../mod/core.html#keepalivetimeout">KeepAliveTimeout</a></code></li><li><code class="directive"><a href="../mod/prefork.html#maxspareservers">MaxSpareServers</a></code></li><li><code class="directive"><a href="../mod/prefork.html#minspareservers">MinSpareServers</a></code></li><li><code class="directive"><a href="../mod/core.html#options">Options</a></code></li><li><code class="directive"><a href="../mod/mpm_common.html#startservers">StartServers</a></code></li></ul></td></tr></table>

    <h3><a name="dns" id="dns">HostnameLookups et autres consid&#233;rations &#224; propos du DNS</a></h3>

      

      <p>Avant Apache 1.3, la directive
      <code class="directive"><a href="../mod/core.html#hostnamelookups">HostnameLookups</a></code> &#233;tait positionn&#233;e
      par d&#233;faut &#224; <code>On</code>, ce qui impliquait une recherche DNS et donc un temps d'attente
      suppl&#233;mentaire pour chaque requ&#234;te. Avec Apache 2.4, <code class="directive"><a href="../mod/core.html#hostnamelookups">HostnameLookups</a></code> est positionn&#233;e par d&#233;faut &#224;
      <code>Off</code>. Si vous avez besoin de convertir des adresses IP en noms
      d'h&#244;tes dans vos fichiers journaux, il est pr&#233;f&#233;rable d'effectuer un
      traitement &#224; post&#233;riori plut&#244;t que de forcer Apache &#224; le faire en temps
      r&#233;el. Il est recommand&#233; d'effectuer ce genre de traitement a posteriori
      de vos fichiers journaux sur une autre machine que celle qui h&#233;berge le
      serveur web en production, afin que cette activit&#233; n'affecte pas les
      performances du serveur.</p>

      <p>Si vous utilisez une directive
      <code><code class="directive"><a href="../mod/mod_access_compat.html#allow">Allow</a></code>from domain</code>
      ou
      <code><code class="directive"><a href="../mod/mod_access_compat.html#deny">Deny</a></code> from domain</code>
      (ce qui signifie que vous utilisez un nom d'h&#244;te ou un nom de domaine &#224;
      la place d'une adresse IP), vous devrez compter avec deux recherches
      DNS (une recherche inverse suivie d'une recherche directe pour
      s'assurer que l'adresse IP n'a pas &#233;t&#233; usurp&#233;e). C'est pourquoi il est
      pr&#233;f&#233;rable, pour am&#233;liorer les performances, et chaque fois que c'est
      possible, d'utiliser des adresses IP plut&#244;t que des noms de domaines.</p>

      <div class="warning"><h3>Avertissement :</h3>
      <p>Veuillez utiliser la directive <code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code> avec Apache 2.4 ; pour plus de
      d&#233;tails, reportez-vous au <a href="../upgrading.html">guide de mise &#224;
      jour</a> correspondant.</p>
      </div>

      <p>Notez qu'il est possible de modifier la port&#233;e des directives, en les
      pla&#231;ant par exemple &#224; l'int&#233;rieur d'une section
      <code>&lt;Location "/server-status"&gt;</code>. Les recherches DNS ne
      seront alors effectu&#233;es que pour les requ&#234;tes qui satisfont aux crit&#232;res.
      Voici un exemple qui d&#233;sactive les recherches DNS sauf pour les fichiers
      <code>.html</code> et <code>.cgi</code> :</p>

      <pre class="prettyprint lang-config">&lt;Files ~ "\.(html|cgi)$"&gt;
  HostnameLookups on
&lt;/Files&gt;</pre>


      <p>Mais m&#234;me dans ce cas, si vous n'avez besoin de noms DNS que dans
      certains CGIs, vous pouvez effectuer l'appel &#224; <code>gethostbyname</code>
      dans les CGIs sp&#233;cifiques qui en ont besoin.</p>

    

    <h3><a name="symlinks" id="symlinks">FollowSymLinks et SymLinksIfOwnerMatch</a></h3>

      

      <p>Chaque fois que la ligne <code>Options FollowSymLinks</code> sera
      absente, ou que la ligne <code>Options SymLinksIfOwnerMatch</code> sera
      pr&#233;sente dans votre espace d'adressage, Apache devra effectuer des
      appels syst&#232;me suppl&#233;mentaires pour v&#233;rifier la pr&#233;sence de liens
      symboliques. Un appel suppl&#233;mentaire par &#233;l&#233;ment du chemin du fichier.
      Par exemple, si vous avez :</p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  Options SymLinksIfOwnerMatch
&lt;/Directory&gt;</pre>


      <p>et si une requ&#234;te demande l'URI <code>/index.html</code>, Apache
      effectuera un appel &#224; <code>lstat(2)</code> pour
      <code>/www</code>, <code>/www/htdocs</code>, et
      <code>/www/htdocs/index.html</code>. Les r&#233;sultats de ces appels &#224;
      <code>lstat</code> ne sont jamais mis en cache, ils devront donc &#234;tre
      g&#233;n&#233;r&#233;s &#224; nouveau pour chaque nouvelle requ&#234;te. Si vous voulez absolument
      v&#233;rifier la s&#233;curit&#233; des liens symboliques, vous pouvez utiliser une
      configuration du style :</p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  Options FollowSymLinks
&lt;/Directory&gt;

&lt;Directory "/www/htdocs"&gt;
  Options -FollowSymLinks +SymLinksIfOwnerMatch
&lt;/Directory&gt;</pre>


      <p>Ceci &#233;vite au moins les v&#233;rifications suppl&#233;mentaires pour le chemin
      d&#233;fini par <code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>. Notez que
      vous devrez ajouter des sections similaires si vous avez des chemins
      d&#233;finis par les directives
      <code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code> ou
      <code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code> en dehors de
      la racine de vos documents. Pour am&#233;liorer les performances, et supprimer
      toute protection des liens symboliques, ajoutez l'option
      <code>FollowSymLinks</code> partout, et n'utilisez jamais l'option
      <code>SymLinksIfOwnerMatch</code>.</p>

    

    <h3><a name="htaccess" id="htaccess">AllowOverride</a></h3>

      

      <p>Dans toute partie de votre espace d'adressage o&#249; vous autoriserez
      la surcharge de la configuration (en g&#233;n&#233;ral &#224; l'aide de fichiers
      <code>.htaccess</code>), Apache va tenter d'ouvrir <code>.htaccess</code>
      pour chaque &#233;l&#233;ment du chemin du fichier demand&#233;. Par exemple, si vous
      avez : </p>

      <pre class="prettyprint lang-config">DocumentRoot "/www/htdocs"
&lt;Directory "/"&gt;
  AllowOverride all
&lt;/Directory&gt;</pre>


      <p>et qu'une requ&#234;te demande l'URI <code>/index.html</code>, Apache
      tentera d'ouvrir <code>/.htaccess</code>, <code>/www/.htaccess</code>,
      et <code>/www/htdocs/.htaccess</code>. Les solutions sont similaires &#224;
      celles &#233;voqu&#233;es pr&#233;c&#233;demment pour <code>Options FollowSymLinks</code>.
      Pour am&#233;liorer les performances, utilisez <code>AllowOverride None</code>
      pour tous les niveaux de votre espace d'adressage.</p>

    

    <h3><a name="negotiation" id="negotiation">N&#233;gociation</a></h3>

      

      <p>Dans la mesure du possible, &#233;vitez toute n&#233;gociation de contenu si
      vous tenez au moindre gain en performances. En pratique toutefois,
      les b&#233;n&#233;fices de la n&#233;gociation l'emportent souvent sur la diminution
      des performances.
      Il y a cependant un cas dans lequel vous pouvez acc&#233;l&#233;rer le serveur.
      Au lieu d'utiliser une directive g&#233;n&#233;rique comme :</p>

      <pre class="prettyprint lang-config">DirectoryIndex index</pre>


      <p>utilisez une liste explicite d'options :</p>

      <pre class="prettyprint lang-config">DirectoryIndex index.cgi index.pl index.shtml index.html</pre>


      <p>o&#249; vous placez le choix courant en premi&#232;re position.</p>

      <p>Notez aussi que cr&#233;er explicitement un fichier de
      <code>correspondances de type</code> fournit de meilleures performances
      que l'utilisation des <code>MultiViews</code>, car les informations
      n&#233;cessaires peuvent &#234;tre simplement obtenues en lisant ce fichier, sans
      avoir &#224; parcourir le r&#233;pertoire &#224; la recherche de types de fichiers.</p>

    <p>Par cons&#233;quent, si la n&#233;gociation de contenu est n&#233;cessaire pour votre
    site, pr&#233;f&#233;rez les fichiers de <code>correspondances de type</code> aux
    directives <code>Options MultiViews</code> pour mener &#224; bien cette
    n&#233;gociation. Se r&#233;f&#233;rer au document sur la
    <a href="../content-negotiation.html">N&#233;gociation de contenu</a> pour une
    description compl&#232;te des m&#233;thodes de n&#233;gociation, et les instructions
    permettant de cr&#233;er des fichiers de <code>correspondances de type</code>.</p>

    

    <h3>Transfert en m&#233;moire</h3>

      

      <p>Dans les situations o&#249; Apache 2.x doit consulter le contenu d'un
      fichier en train d'&#234;tre servi - par exemple &#224; l'occasion du traitement
      d'une inclusion c&#244;t&#233; serveur - il transf&#232;re en g&#233;n&#233;ral le fichier en
      m&#233;moire si le syst&#232;me d'exploitation supporte une forme quelconque
      de <code>mmap(2)</code>.</p>

      <p>Sur certains syst&#232;mes, ce transfert en m&#233;moire am&#233;liore les
      performances. Dans certains cas, ce transfert peut toutefois les d&#233;grader
      et m&#234;me diminuer la stabilit&#233; du d&#233;mon httpd :</p>

      <ul>
        <li>
          <p>Dans certains syst&#232;mes d'exploitation, <code>mmap</code> devient
	  moins efficace que <code>read(2)</code> quand le nombre de
	  processeurs augmente. Sur les serveurs multiprocesseurs sous Solaris,
	  par exemple, Apache 2.x sert parfois les fichiers consult&#233;s par le
	  serveur plus rapidement quand <code>mmap</code> est d&#233;sactiv&#233;.</p>
        </li>

        <li>
          <p>Si vous transf&#233;rez en m&#233;moire un fichier localis&#233; dans un syst&#232;me
	  de fichiers mont&#233; par NFS, et si un processus sur
	  une autre machine cliente NFS supprime ou tronque le fichier, votre
	  processus peut rencontrer une erreur de bus la prochaine fois qu'il
	  essaiera d'acc&#233;der au contenu du fichier en m&#233;moire.</p>
        </li>
      </ul>

      <p>Pour les installations o&#249; une de ces situations peut se produire,
      vous devez utiliser <code>EnableMMAP off</code> afin de d&#233;sactiver le
      transfert en m&#233;moire des fichiers servis. (Note : il est possible de
      passer outre cette directive au niveau de chaque r&#233;pertoire.)</p>

    

    <h3>Sendfile</h3>

      

      <p>Dans les cas o&#249; Apache peut se permettre d'ignorer le contenu du
      fichier &#224; servir - par exemple, lorsqu'il sert un contenu de fichier
      statique - il utilise en g&#233;n&#233;ral le support sendfile du noyau si le
      syst&#232;me d'exploitation supporte l'op&#233;ration <code>sendfile(2)</code>.</p>

      <p>Sur la plupart des plateformes, l'utilisation de sendfile am&#233;liore
      les performances en &#233;liminant les m&#233;canismes de lecture et envoi s&#233;par&#233;s.
      Dans certains cas cependant, l'utilisation de sendfile peut nuire &#224; la
      stabilit&#233; du d&#233;mon httpd :</p>

      <ul>
        <li>
          <p>Certaines plateformes peuvent pr&#233;senter un support de sendfile
	  d&#233;faillant que la construction du syst&#232;me n'a pas d&#233;tect&#233;, en
	  particulier si les binaires ont &#233;t&#233; construits sur une autre machine
	  et transf&#233;r&#233;s sur la machine o&#249; le support de sendfile est
	  d&#233;faillant.</p>
        </li>
        <li>
          <p>Dans le cas d'un syst&#232;me de fichiers mont&#233;
	  sous NFS, le noyau peut s'av&#233;rer incapable de servir
	  les fichiers r&#233;seau de mani&#232;re fiable depuis
	  son propre cache.</p>
        </li>
      </ul>

      <p>Pour les installations o&#249; une de ces situations peut se produire,
      vous devez utiliser <code>EnableSendfile off</code> afin de d&#233;sactiver
      la mise &#224; disposition de contenus de fichiers par sendfile. (Note : il
      est possible de passer outre cette directive au niveau de chaque
      r&#233;pertoire.)</p>

    

    <h3><a name="process" id="process">Recyclage des processus enfants</a></h3>

      

    <p>La directive <code class="directive"><a href="../mod/mpm_common.html#maxconnectionsperchild">MaxConnectionsPerChild</a></code> permet de limiter le
    nombre de connexions qu'un processus enfant peut g&#233;rer au cours de sa vie
    (par d&#233;faut, la valeur est <code>0</code>, soit aucune limite). Tous les <a href="../mpm.html#defaults">MPMs</a> sont concern&#233;s, m&#234;me ceux qui utilisent
    des threads. Par exemple, chaque processus cr&#233;&#233; par le MPM
    <code class="module"><a href="../mod/worker.html">worker</a></code> lance plusieurs threads qui g&#232;rent les connexions,
    mais cette directive n'en affecte pas le nombre total. Cela signifie
    seulement que la valeur de la directive <code class="directive"><a href="../mod/mpm_common.html#maxconnectionsperchild">MaxConnectionsPerChild</a></code> ne limitera que le
    nombre de requ&#234;tes trait&#233;es par les threads lanc&#233;s par un seul processus
    enfant.</p>

    <p>Dans des conditions d'utilisation optimales, la directive <code class="directive"><a href="../mod/mpm_common.html#maxconnectionsperchild">MaxConnectionsPerChild</a></code> ne devrait imposer
    aucune limite, car il n'y a &#224; priori aucune raison de tuer un processus, si
    ce n'est suite &#224; un bug logiciel causant des fuites de m&#233;moire ou un usage
    excessif du CPU.</p>   

    <p>Lorsque le mode "keep-alive" est activ&#233;, un processus (ou un thread lanc&#233;
    par un processus) est
    maintenu et ne fait rien sinon attendre la prochaine requ&#234;te sur la
    connexion d&#233;j&#224; ouverte. La valeur par d&#233;faut de <code>5</code> de la
    directive <code class="directive"><a href="../mod/core.html#keepalivetimeout">KeepAliveTimeout</a></code> tend &#224;
    minimiser cet effet. Il faut trouver le bon compromis entre la bande
    passante r&#233;seau et les ressources du serveur.</p>

    

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="compiletime" id="compiletime">Optimisation de la configuration &#224; la compilation</a><a title="Lien permanent" href="#compiletime" class="permalink">&para;</a></h2>

    

    <h3>Choisir un Module Multi-Processus (MPM)</h3>

      

      <p>Apache 2.x supporte les mod&#232;les simultan&#233;s enfichables, appel&#233;s
      <a href="../mpm.html">Modules Multi-Processus</a> (MPMs). Vous devez
      choisir un MPM au moment de la construction d'Apache. Certaines
      plateformes ont des modules MPM sp&#233;cifiques :
      <code class="module"><a href="../mod/mpm_netware.html">mpm_netware</a></code>, <code class="module"><a href="../mod/mpmt_os2.html">mpmt_os2</a></code> et
      <code class="module"><a href="../mod/mpm_winnt.html">mpm_winnt</a></code>. Sur les syst&#232;mes de type Unix, vous avez le
      choix entre un grand nombre de modules MPM. Le choix du MPM peut affecter
      la vitesse et l'&#233;volutivit&#233; du d&#233;mon httpd :</p>

      <ul>

        <li>Le MPM <code class="module"><a href="../mod/worker.html">worker</a></code> utilise plusieurs processus
	enfants poss&#233;dant chacun de nombreux threads. Chaque thread g&#232;re une
	seule connexion &#224; la fois. Worker est en g&#233;n&#233;ral un bon choix pour les
	serveurs pr&#233;sentant un traffic important car il poss&#232;de une empreinte
	m&#233;moire plus petite que le MPM prefork.</li>

	<li>Comme le MPM Worker, le MPM <code class="module"><a href="../mod/event.html">event</a></code> utilise
	les threads, mais il a &#233;t&#233; con&#231;u pour traiter davantage de
	requ&#234;tes simultan&#233;ment en confiant une partie du travail &#224; des
	threads de support, ce qui permet aux threads principaux de
	traiter de nouvelles requ&#234;tes.</li>

        <li>Le MPM <code class="module"><a href="../mod/prefork.html">prefork</a></code> utilise plusieurs processus enfants
	poss&#233;dant chacun un seul thread. Chaque processus g&#232;re une seule
	connexion &#224; la fois. Sur de nombreux syst&#232;mes, prefork est comparable
	en mati&#232;re de vitesse &#224; worker, mais il utilise plus de m&#233;moire. De par
	sa conception sans thread, prefork pr&#233;sente des avantages par rapport &#224;
	worker dans certaines situations : il peut &#234;tre utilis&#233; avec les
	modules tiers qui ne supportent pas le threading, et son d&#233;bogage est plus
	ais&#233; sur les platesformes pr&#233;sentant un support du d&#233;bogage des threads
	rudimentaire.</li>

      </ul>

      <p>Pour plus d'informations sur ces deux MPMs et les autres, veuillez
      vous r&#233;f&#233;rer &#224; la <a href="../mpm.html">documentation sur les
      MPM</a>.</p>

    

    <h3><a name="modules" id="modules">Modules</a></h3>

        

        <p>Comme le contr&#244;le de l'utilisation de la m&#233;moire est tr&#232;s important
	en mati&#232;re de performance, il est conseill&#233; d'&#233;liminer les modules que
	vous n'utilisez pas vraiment. Si vous avez construit ces modules en
	tant que <a href="../dso.html">DSOs</a>, leur &#233;limination consiste
	simplement &#224; commenter la directive
	<code class="directive"><a href="../mod/mod_so.html#loadmodule">LoadModule</a></code> associ&#233;e &#224; ce
	module. Ceci vous permet de v&#233;rifier si votre site fonctionne toujours
	apr&#232;s la suppression de tel ou tel module.</p>

        <p>Par contre, si les modules que vous voulez supprimer sont li&#233;s
	statiquement &#224; votre binaire Apache, vous devrez recompiler ce dernier
	afin de pouvoir les &#233;liminer.</p>

        <p>La question qui d&#233;coule de ce qui pr&#233;c&#232;de est &#233;videmment de
	savoir de quels modules vous avez besoin et desquels vous pouvez vous
	passer. La r&#233;ponse sera bien entendu diff&#233;rente d'un site web &#224;
	l'autre. Cependant, la liste <em>minimale</em> de modules n&#233;cessaire &#224;
	la survie de votre site contiendra certainement
	<code class="module"><a href="../mod/mod_mime.html">mod_mime</a></code>, <code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code> et
	<code class="module"><a href="../mod/mod_log_config.html">mod_log_config</a></code>. <code>mod_log_config</code> est bien
	entendu optionnel puisque vous pouvez faire fonctionner un site web
	en se passant de fichiers journaux ; ceci est cependant
	d&#233;conseill&#233;.</p>

    

    <h3>Op&#233;rations atomiques</h3>

      

      <p>Certains modules, &#224; l'instar de <code class="module"><a href="../mod/mod_cache.html">mod_cache</a></code> et des
      versions de d&#233;veloppement r&#233;centes du MPM worker, utilisent l'API
      atomique d'APR. Cette API propose des op&#233;rations atomiques que l'on
      peut utiliser pour all&#233;ger la synchronisation des threads.</p>

      <p>Par d&#233;faut, APR impl&#233;mente ces op&#233;rations en utilisant les
      m&#233;canismes les plus efficaces disponibles sur chaque plateforme cible
      (Syst&#232;me d'exploitation et processeur). De nombreux processeurs modernes,
      par exemple, poss&#232;dent une instruction qui effectue une op&#233;ration
      atomique de type comparaison et &#233;change ou compare-and-swap (CAS) au
      niveau mat&#233;riel. Sur certaines platesformes cependant, APR utilise par
      d&#233;faut une impl&#233;mentation de l'API atomique plus lente, bas&#233;e sur les
      mutex, afin d'assurer la compatibilit&#233; avec les anciens mod&#232;les de
      processeurs qui ne poss&#232;dent pas ce genre d'instruction. Si vous
      construisez Apache pour une de ces platesformes, et ne pr&#233;voyez de
      l'ex&#233;cuter que sur des processeurs r&#233;cents, vous pouvez s&#233;lectionner une
      impl&#233;mentation atomique plus rapide &#224; la compilation en utilisant
      l'option <code>--enable-nonportable-atomics</code> du
      script configure :</p>

      <div class="example"><p><code>
        ./buildconf<br />
        ./configure --with-mpm=worker --enable-nonportable-atomics=yes
      </code></p></div>

      <p>L'option <code>--enable-nonportable-atomics</code> concerne les
      platesformes suivantes :</p>

      <ul>

        <li>Solaris sur SPARC<br />
            Sur Solaris/SPARC, APR utilise par d&#233;faut les op&#233;rations
	    atomiques bas&#233;es sur les mutex. Cependant, si vous ajoutez l'option
	    <code>--enable-nonportable-atomics</code> au script configure, APR
	    g&#233;n&#232;re un code qui utilise le code op&#233;ration SPARC v8plus pour des
	    op&#233;rations de compare-and-swap mat&#233;riel plus rapides. Si vous
	    utilisez cette option de configure avec Apache, les op&#233;rations
	    atomiques seront plus efficaces (permettant d'all&#233;ger la charge du
	    processeur et un plus haut niveau de simultan&#233;it&#233;), mais
	    l'ex&#233;cutable produit ne fonctionnera que sur les processeurs
	    UltraSPARC.
	</li>

        <li>Linux sur x86<br />
            Sous Linux, APR utilise par d&#233;faut les op&#233;rations atomiques bas&#233;es
	    sur les mutex. Cependant, si vous ajoutez l'option
	    <code>--enable-nonportable-atomics</code> au script configure,
	    APR g&#233;n&#233;rera un code qui utilise un code d'op&#233;ration du 486
	    pour des op&#233;rations de compare-and-swap mat&#233;riel plus rapides. Le
	    code r&#233;sultant est plus efficace en mati&#232;re d'op&#233;rations atomiques,
	    mais l'ex&#233;cutable produit ne fonctionnera que sur des processeurs
	    486 et sup&#233;rieurs (et non sur des 386).
        </li>

      </ul>

    

    <h3>Module mod_status et ExtendedStatus On</h3>

      

      <p>Si vous incluez le module <code class="module"><a href="../mod/mod_status.html">mod_status</a></code> &#224; la
      construction d'Apache et ajoutez <code>ExtendedStatus On</code> &#224; sa
      configuration, Apache va effectuer pour chaque requ&#234;te deux appels &#224;
      <code>gettimeofday(2)</code> (ou <code>times(2)</code> selon votre
      syst&#232;me d'exploitation), et (pour les versions ant&#233;rieures &#224; 1.3) de
      nombreux appels suppl&#233;mentaires &#224; <code>time(2)</code>. Tous ces
      appels sont effectu&#233;s afin que le rapport de statut puisse contenir
      des indications temporelles. Pour am&#233;liorer les performances, utilisez
      <code>ExtendedStatus off</code> (qui est le r&#233;glage par d&#233;faut).</p>

    

    <h3>accept Serialization - points de connexion &#224; un programme (sockets) multiples</h3>

      

    <div class="warning"><h3>Mise en garde :</h3>
      <p>Cette section n'a pas &#233;t&#233; totalement mise &#224; jour car elle ne tient pas
      compte des changements intervenus dans la version 2.x du Serveur HTTP
      Apache. Certaines informations sont encore pertinentes, il vous est
      cependant conseill&#233; de les utiliser avec prudence.</p>
    </div>

      <p>Ce qui suit est une br&#232;ve discussion &#224; propos de l'API des sockets
      Unix. Supposons que votre serveur web utilise plusieurs directives
      <code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code> afin d'&#233;couter
      plusieurs ports ou de multiples adresses. Afin de tester chaque socket
      pour voir s'il a une connexion en attente, Apache utilise
      <code>select(2)</code>. <code>select(2)</code> indique si un socket a
      <em>z&#233;ro</em> ou <em>au moins une</em> connexion en attente. Le mod&#232;le
      d'Apache comporte plusieurs processus enfants, et tous ceux qui sont
      inactifs testent la pr&#233;sence de nouvelles connexions au m&#234;me moment.
      Une impl&#233;mentation rudimentaire de ceci pourrait ressembler &#224;
      l'exemple suivant
      (ces exemples ne sont pas extraits du code d'Apache, ils ne sont
      propos&#233;s qu'&#224; des fins p&#233;dagogiques) :</p>

      <pre class="prettyprint lang-c">        for (;;) {
          for (;;) {
            fd_set accept_fds;

            FD_ZERO (&amp;accept_fds);
            for (i = first_socket; i &lt;= last_socket; ++i) {
              FD_SET (i, &amp;accept_fds);
            }
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);
            if (rc &lt; 1) continue;
            new_connection = -1;
            for (i = first_socket; i &lt;= last_socket; ++i) {
              if (FD_ISSET (i, &amp;accept_fds)) {
                new_connection = accept (i, NULL, NULL);
                if (new_connection != -1) break;
              }
            }
            if (new_connection != -1) break;
          }
          process_the(new_connection);
        }</pre>


      <p>Mais cette impl&#233;mentation rudimentaire pr&#233;sente une s&#233;rieuse lacune.
      Rappelez-vous que les processus enfants ex&#233;cutent cette boucle au m&#234;me
      moment ; ils vont ainsi bloquer sur <code>select</code> s'ils se trouvent
      entre deux requ&#234;tes. Tous ces processus bloqu&#233;s vont se r&#233;activer et
      sortir de <code>select</code> quand une requ&#234;te va appara&#238;tre sur un des
      sockets (le nombre de processus enfants qui se r&#233;activent varie en
      fonction du syst&#232;me d'exploitation et des r&#233;glages de synchronisation).
      Ils vont alors tous entrer dans la boucle et tenter un
      <code>"accept"</code> de la connexion. Mais seulement un d'entre eux y
      parviendra (en supposant qu'il ne reste q'une seule connexion en
      attente), les autres vont se bloquer au niveau de <code>accept</code>.
      Ceci verrouille vraiment ces processus de telle sorte qu'ils ne peuvent
      plus servir de requ&#234;tes que par cet unique socket, et il en sera ainsi
      jusqu'&#224; ce que suffisamment de nouvelles requ&#234;tes apparaissent sur ce
      socket pour les r&#233;activer tous. Cette lacune a &#233;t&#233; document&#233;e pour la
      premi&#232;re fois dans
      <a href="http://bugs.apache.org/index/full/467">PR#467</a>. Il existe
      au moins deux solutions.</p>

      <p>La premi&#232;re consiste &#224; rendre les sockets non blocants. Dans ce cas,
      <code>accept</code> ne bloquera pas les processus enfants, et ils
      pourront continuer &#224; s'ex&#233;cuter imm&#233;diatement. Mais ceci consomme des
      ressources processeur. Supposons que vous ayez dix processus enfants
      inactifs dans <code>select</code>, et qu'une connexion arrive.
      Neuf des dix processus vont se r&#233;activer, tenter un <code>accept</code>
      de la connexion, &#233;chouer, et boucler dans <code>select</code>, tout en
      n'ayant finalement rien accompli. Pendant ce temps, aucun de ces processus
      ne traite les requ&#234;tes qui arrivent sur d'autres sockets jusqu'&#224; ce
      qu'ils retournent dans <code>select</code>. Finalement, cette solution
      ne semble pas tr&#232;s efficace, &#224; moins que vous ne disposiez d'autant de
      processeurs inactifs (dans un serveur multiprocesseur) que de processus
      enfants inactifs, ce qui n'est pas une situation tr&#232;s courante.</p>

      <p>Une autre solution, celle qu'utilise Apache, consiste &#224; s&#233;rialiser les
      entr&#233;es dans la boucle interne. La boucle ressemble &#224; ceci (les
      diff&#233;rences sont mises en surbrillance) :</p>

      <pre class="prettyprint lang-c">        for (;;) {
          <strong>accept_mutex_on ();</strong>
          for (;;) {
            fd_set accept_fds;
            
            FD_ZERO (&amp;accept_fds);
            for (i = first_socket; i &lt;= last_socket; ++i) {
              FD_SET (i, &amp;accept_fds);
            }
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);
            if (rc &lt; 1) continue;
            new_connection = -1;
            for (i = first_socket; i &lt;= last_socket; ++i) {
              if (FD_ISSET (i, &amp;accept_fds)) {
                new_connection = accept (i, NULL, NULL);
                if (new_connection != -1) break;
              }
            }
            if (new_connection != -1) break;
          }
          <strong>accept_mutex_off ();</strong>
          process the new_connection;
        }</pre>


      <p><a id="serialize" name="serialize">Les fonctions</a>
      <code>accept_mutex_on</code> et <code>accept_mutex_off</code>
      impl&#233;mentent un s&#233;maphore permettant une exclusion mutuelle. Un seul
      processus enfant &#224; la fois peut poss&#233;der le mutex. Plusieurs choix se
      pr&#233;sentent pour impl&#233;menter ces mutex. Ce choix est d&#233;fini dans
      <code>src/conf.h</code> (versions ant&#233;rieures &#224; 1.3) ou
      <code>src/include/ap_config.h</code> (versions 1.3 ou sup&#233;rieures).
      Certaines architectures ne font pas ce choix du mode de verrouillage ;
      l'utilisation de directives
      <code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code> multiples sur ces
      architectures est donc peu s&#251;r.</p>

      <p>La directive <code class="directive"><a href="../mod/core.html#mutex">Mutex</a></code> permet
      de modifier l'impl&#233;mentation du mutex <code>mpm-accept</code> &#224;
      l'ex&#233;cution. Des consid&#233;rations sp&#233;cifiques aux diff&#233;rentes
      impl&#233;mentations de mutex sont document&#233;es avec cette directive.</p>

      <p>Une autre solution qui a &#233;t&#233; imagin&#233;e mais jamais impl&#233;ment&#233;e, consiste
      &#224; s&#233;rialiser partiellement la boucle -- c'est &#224; dire y faire entrer un
      certain nombre de processus. Ceci ne pr&#233;senterait un int&#233;r&#234;t que sur les
      machines multiprocesseurs o&#249; plusieurs processus enfants peuvent
      s'ex&#233;cuter simultan&#233;ment, et encore, la s&#233;rialisation ne tire pas
      vraiment parti de toute la bande passante. C'est une possibilit&#233;
      d'investigation future, mais demeure de priorit&#233; basse car les serveurs
      web &#224; architecture hautement parall&#232;le ne sont pas la norme.</p>

      <p>Pour bien faire, vous devriez faire fonctionner votre serveur sans
      directives <code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code> multiples
      si vous visez les performances les plus &#233;lev&#233;es.
      Mais lisez ce qui suit.</p>

    

    <h3>accept Serialization - point de connexion &#224; un programme (sockets) unique</h3>

      

      <p>Ce qui pr&#233;c&#232;de convient pour les serveurs &#224; sockets multiples, mais
      qu'en est-il des serveurs &#224; socket unique ? En th&#233;orie, ils ne
      devraient pas rencontrer les m&#234;mes probl&#232;mes car tous les processus
      enfants peuvent se bloquer dans <code>accept(2)</code> jusqu'&#224; ce qu'une
      connexion arrive, et ils ne sont pas utilis&#233;s &#224; ne rien faire. En
      pratique, ceci dissimule un m&#234;me comportement de bouclage
      discut&#233; plus haut dans la solution non-blocante. De la mani&#232;re dont
      sont impl&#233;ment&#233;es les piles TCP, le noyau r&#233;active v&#233;ritablement tous les
      processus bloqu&#233;s dans <code>accept</code> quand une seule connexion
      arrive. Un de ces processus prend la connexion en compte et retourne
      dans l'espace utilisateur, les autres bouclant dans l'espace du
      noyau et se d&#233;sactivant quand ils s'aper&#231;oivent qu'il n'y a pas de
      connexion pour eux. Ce bouclage est invisible depuis le code de l'espace
      utilisateur, mais il est quand-m&#234;me pr&#233;sent. Ceci peut conduire &#224; la
      m&#234;me augmentation de charge &#224; perte que la solution non blocante au cas
      des sockets multiples peut induire.</p>

      <p>Pour cette raison, il appara&#238;t que de nombreuses architectures se
      comportent plus "proprement" si on s&#233;rialise m&#234;me dans le cas d'une socket
      unique. Il s'agit en fait du comportement par d&#233;faut dans la plupart des
      cas. Des exp&#233;riences pouss&#233;es sous Linux (noyau 2.0.30 sur un
      biprocesseur Pentium pro 166 avec 128 Mo de RAM) ont montr&#233; que la
      s&#233;rialisation d'une socket unique provoque une diminution inf&#233;rieure &#224; 3%
      du nombre de requ&#234;tes par secondes par rapport au traitement non
      s&#233;rialis&#233;. Mais le traitement non s&#233;rialis&#233; des sockets uniques induit
      un temps de r&#233;ponse suppl&#233;mentaire de 100 ms pour chaque requ&#234;te. Ce
      temps de r&#233;ponse est probablement provoqu&#233; par une limitation sur les
      lignes &#224; haute charge, et ne constitue un probl&#232;me que sur les r&#233;seaux
      locaux. Si vous voulez vous passer de la s&#233;rialisation des sockets
      uniques, vous pouvez d&#233;finir
      <code>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</code> et les
      serveurs &#224; socket unique ne pratiqueront plus du tout la
      s&#233;rialisation.</p>

    

    <h3>Fermeture en prenant son temps (Lingering close)</h3>

      

      <p>Comme discut&#233; dans <a href="http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-connection-00.txt">
      draft-ietf-http-connection-00.txt</a> section 8, pour impl&#233;menter de
      mani&#232;re <strong>fiable</strong> le protocole, un serveur HTTP doit fermer
      les deux directions d'une communication ind&#233;pendamment (rappelez-vous
      qu'une connexion TCP est bidirectionnelle, chaque direction &#233;tant
      ind&#233;pendante de l'autre).</p>

      <p>Quand cette fonctionnalit&#233; fut ajout&#233;e &#224; Apache, elle causa une
      avalanche de probl&#232;mes sur plusieurs versions d'Unix &#224; cause d'une
      impl&#233;mentation &#224; courte vue. La sp&#233;cification TCP ne pr&#233;cise pas que
      l'&#233;tat <code>FIN_WAIT_2</code> poss&#232;de un temps de r&#233;ponse mais elle ne
      l'exclut pas. Sur les syst&#232;mes qui n'introduisent pas ce temps de
      r&#233;ponse, Apache 1.2 induit de nombreux blocages d&#233;finitifs de socket
      dans l'&#233;tat <code>FIN_WAIT_2</code>. On peut eviter ceci dans de nombreux
      cas tout simplement en mettant &#224; jour TCP/IP avec le dernier patch mis &#224;
      disposition par le fournisseur. Dans les cas o&#249; le fournisseur n'a
      jamais fourni de patch (par exemple, SunOS4 -- bien que les utilisateurs
      poss&#233;dant une license source puissent le patcher eux-m&#234;mes), nous avons
      d&#233;cid&#233; de d&#233;sactiver cette fonctionnalit&#233;.</p>

      <p>Il y a deux m&#233;thodes pour arriver &#224; ce r&#233;sultat. La premi&#232;re est
      l'option de socket <code>SO_LINGER</code>. Mais le sort a voulu que cette
      solution ne soit jamais impl&#233;ment&#233;e correctement dans la plupart des
      piles TCP/IP. Et m&#234;me dans les rares cas o&#249; cette solution a &#233;t&#233;
      impl&#233;ment&#233;e correctement (par exemple Linux 2.0.31), elle se
      montre beaucoup plus gourmande (en temps processeur) que la solution
      suivante.</p>

      <p>Pour la plus grande partie, Apache impl&#233;mente cette solution &#224; l'aide
      d'une fonction appel&#233;e <code>lingering_close</code> (d&#233;finie dans
      <code>http_main.c</code>). La fonction ressemble approximativement &#224;
      ceci :</p>

      <pre class="prettyprint lang-c">        void lingering_close (int s)
        {
          char junk_buffer[2048];
          
          /* shutdown the sending side */
          shutdown (s, 1);

          signal (SIGALRM, lingering_death);
          alarm (30);

          for (;;) {
            select (s for reading, 2 second timeout);
            if (error) break;
            if (s is ready for reading) {
              if (read (s, junk_buffer, sizeof (junk_buffer)) &lt;= 0) {
                break;
              }
              /* just toss away whatever is here */
            }
          }
          
          close (s);
        }</pre>


      <p>Ceci ajoute naturellement un peu de charge &#224; la fin d'une connexion,
      mais s'av&#232;re n&#233;cessaire pour une impl&#233;mentation fiable. Comme HTTP/1.1
      est de plus en plus pr&#233;sent et que toutes les connexions sont
      persistentes, la charge sera amortie par la multiplicit&#233; des requ&#234;tes.
      Si vous voulez jouer avec le feu en d&#233;sactivant cette fonctionnalit&#233;,
      vous pouvez d&#233;finir <code>NO_LINGCLOSE</code>, mais c'est fortement
      d&#233;conseill&#233;. En particulier, comme les connexions persistantes en
      pipeline de HTTP/1.1 commencent &#224; &#234;tre utilis&#233;es,
      <code>lingering_close</code> devient une absolue n&#233;cessit&#233; (et les
      <a href="http://www.w3.org/Protocols/HTTP/Performance/Pipeline.html">
      connexions en pipeline sont plus rapides</a> ; vous avez donc tout
      int&#233;r&#234;t &#224; les supporter).</p>

    

    <h3>Fichier tableau de bord (Scoreboard file)</h3>

      

      <p>Les processus parent et enfants d'Apache communiquent entre eux &#224;
      l'aide d'un objet appel&#233; "Tableau de bord" (Scoreboard). Id&#233;alement, cet
      &#233;change devrait s'effectuer en m&#233;moire partag&#233;e. Pour les syst&#232;mes
      d'exploitation auxquels nous avons eu acc&#232;s, ou pour lesquels nous avons
      obtenu des informations suffisamment d&#233;taill&#233;es pour effectuer un
      portage, cet &#233;change est en g&#233;n&#233;ral impl&#233;ment&#233; en utilisant la m&#233;moire
      partag&#233;e. Pour les autres, on utilise par d&#233;faut un fichier d'&#233;change sur
      disque. Le fichier d'&#233;change sur disque est non seulement lent, mais
      aussi peu fiable (et propose moins de fonctionnalit&#233;s). Recherchez dans
      le fichier <code>src/main/conf.h</code> correspondant &#224; votre
      architecture soit <code>USE_MMAP_SCOREBOARD</code>, soit
      <code>USE_SHMGET_SCOREBOARD</code>. La d&#233;finition de l'un des deux
      (ainsi que leurs compagnons respectifs <code>HAVE_MMAP</code> et
      <code>HAVE_SHMGET</code>), active le code fourni pour la m&#233;moire
      partag&#233;e. Si votre syst&#232;me propose une autre solution pour la gestion de
      la m&#233;moire partag&#233;e, &#233;ditez le fichier <code>src/main/http_main.c</code>
      et ajoutez la portion de code n&#233;cessaire pour pouvoir l'utiliser dans
      Apache (Merci de nous envoyer aussi le patch correspondant).</p>

      <div class="note">Note &#224; caract&#232;re historique : le portage d'Apache sous Linux
      n'utilisait pas la m&#233;moire partag&#233;e avant la version 1.2. Ceci entra&#238;nait
      un comportement tr&#232;s rudimentaire et peu fiable des versions ant&#233;rieures
      d'Apache sous Linux.</div>

    

    <h3>DYNAMIC_MODULE_LIMIT</h3>

      

      <p>Si vous n'avez pas l'intention d'utiliser les modules charg&#233;s
      dynamiquement (ce qui est probablement le cas si vous &#234;tes en train de
      lire ce document afin de personnaliser votre serveur en recherchant le
      moindre des gains en performances), vous pouvez ajouter la d&#233;finition
      <code>-DDYNAMIC_MODULE_LIMIT=0</code> &#224; la construction de votre serveur.
      Ceci aura pour effet de lib&#233;rer la m&#233;moire RAM allou&#233;e pour le
      chargement dynamique des modules.</p>

    

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="trace" id="trace">Appendice : Analyse d&#233;taill&#233;e d'une trace</a><a title="Lien permanent" href="#trace" class="permalink">&para;</a></h2>

    

    <p>Voici la trace d'un appel syst&#232;me d'Apache 2.0.38 avec le MPM worker
    sous Solaris 8. Cette trace a &#233;t&#233; collect&#233;e &#224; l'aide de la commande :</p>

    <div class="example"><p><code>
      truss -l -p <var>httpd_child_pid</var>.
    </code></p></div>

    <p>L'option <code>-l</code> demande &#224; truss de tracer l'ID du LWP
    (lightweight process--la version de Solaris des threads niveau noyau) qui
    invoque chaque appel syst&#232;me.</p>

    <p>Les autres syst&#232;mes peuvent proposer des utilitaires de tra&#231;age
    des appels syst&#232;me diff&#233;rents comme <code>strace</code>,
    <code>ktrace</code>, ou <code>par</code>. Ils produisent cependant tous une
    trace similaire.</p>

    <p>Dans cette trace, un client a demand&#233; un fichier statique de 10 ko au
    d&#233;mon httpd. Le tra&#231;age des requ&#234;tes pour des contenus non statiques
    ou comportant une n&#233;gociation de contenu a une pr&#233;sentation
    diff&#233;rente (et m&#234;me assez laide dans certains cas).</p>

    <div class="example"><pre>/67:    accept(3, 0x00200BEC, 0x00200C0C, 1) (sleeping...)
/67:    accept(3, 0x00200BEC, 0x00200C0C, 1)            = 9</pre></div>

    <p>Dans cette trace, le thread &#224; l'&#233;coute s'ex&#233;cute &#224; l'int&#233;rieur de
    LWP #67.</p>

    <div class="note">Notez l'absence de la s&#233;rialisation d'<code>accept(2)</code>. Sur
    cette plateforme sp&#233;cifique, le MPM worker utilise un accept non s&#233;rialis&#233;
    par d&#233;faut sauf s'il est en &#233;coute sur des ports multiples.</div>

    <div class="example"><pre>/65:    lwp_park(0x00000000, 0)                         = 0
/67:    lwp_unpark(65, 1)                               = 0</pre></div>

    <p>Apr&#232;s avoir accept&#233; la connexion, le thread &#224; l'&#233;coute r&#233;active un
    thread du worker pour effectuer le traitement de la requ&#234;te. Dans cette
    trace, le thread du worker qui traite la requ&#234;te est associ&#233; &#224;
    LWP #65.</p>

    <div class="example"><pre>/65:    getsockname(9, 0x00200BA4, 0x00200BC4, 1)       = 0</pre></div>

    <p>Afin de pouvoir impl&#233;menter les h&#244;tes virtuels, Apache doit conna&#238;tre
    l'adresse du socket local utilis&#233; pour accepter la connexion. On pourrait
    supprimer cet appel dans de nombreuses situations (par exemple dans le cas
    o&#249; il n'y a pas d'h&#244;te virtuel ou dans le cas o&#249; les directives
    <code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code> contiennent des adresses
    sans caract&#232;res de substitution). Mais aucun effort n'a &#233;t&#233; accompli &#224; ce
    jour pour effectuer ces optimisations.</p>

    <div class="example"><pre>/65:    brk(0x002170E8)                                 = 0
/65:    brk(0x002190E8)                                 = 0</pre></div>

    <p>L'appel <code>brk(2)</code> alloue de la m&#233;moire dans le tas. Ceci est
    rarement visible dans une trace d'appel syst&#232;me, car le d&#233;mon httpd
    utilise des allocateurs m&#233;moire de son cru (<code>apr_pool</code> et
    <code>apr_bucket_alloc</code>) pour la plupart des traitements de requ&#234;tes.
    Dans cette trace, le d&#233;mon httpd vient juste de d&#233;marrer, et il doit
    appeler <code>malloc(3)</code> pour r&#233;server les blocs de m&#233;moire
    n&#233;cessaires &#224; la cr&#233;ation de ses propres allocateurs de m&#233;moire.</p>

    <div class="example"><pre>/65:    fcntl(9, F_GETFL, 0x00000000)                   = 2
/65:    fstat64(9, 0xFAF7B818)                          = 0
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B910, 2190656) = 0
/65:    fstat64(9, 0xFAF7B818)                          = 0
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B914, 2190656) = 0
/65:    setsockopt(9, 65535, 8192, 0xFAF7B918, 4, 2190656) = 0
/65:    fcntl(9, F_SETFL, 0x00000082)                   = 0</pre></div>

    <p>Ensuite, le thread de worker passe la connexion du client (descripteur
    de fichier 9) en mode non blocant. Les appels <code>setsockopt(2)</code>
    et <code>getsockopt(2)</code> constituent un effet de bord de la mani&#232;re
    dont la libc de Solaris utilise <code>fcntl(2)</code> pour les sockets.</p>

    <div class="example"><pre>/65:    read(9, " G E T   / 1 0 k . h t m".., 8000)     = 97</pre></div>

    <p>Le thread de worker lit la requ&#234;te du client.</p>

    <div class="example"><pre>/65:    stat("/var/httpd/apache/httpd-8999/htdocs/10k.html", 0xFAF7B978) = 0
/65:    open("/var/httpd/apache/httpd-8999/htdocs/10k.html", O_RDONLY) = 10</pre></div>

    <p>Ce d&#233;mon httpd a &#233;t&#233; configur&#233; avec les options
    <code>Options FollowSymLinks</code> et <code>AllowOverride None</code>. Il
    n'a donc ni besoin d'appeler <code>lstat(2)</code> pour chaque r&#233;pertoire
    du chemin du fichier demand&#233;, ni besoin de v&#233;rifier la pr&#233;sence de fichiers
    <code>.htaccess</code>. Il appelle simplement <code>stat(2)</code> pour
    v&#233;rifier d'une part que le fichier existe, et d'autre part que c'est un
    fichier r&#233;gulier, et non un r&#233;pertoire.</p>

    <div class="example"><pre>/65:    sendfilev(0, 9, 0x00200F90, 2, 0xFAF7B53C)      = 10269</pre></div>

    <p>Dans cet exemple, le d&#233;mon httpd peut envoyer l'en-t&#234;te de la r&#233;ponse
    HTTP et le fichier demand&#233; &#224; l'aide d'un seul appel syst&#232;me
    <code>sendfilev(2)</code>. La s&#233;mantique de sendfile varie en fonction des
    syst&#232;mes d'exploitation. Sur certains autres syst&#232;mes, il faut faire un
    appel &#224; <code>write(2)</code> ou <code>writev(2)</code> pour envoyer les
    en-t&#234;tes avant d'appeler <code>sendfile(2)</code>.</p>

    <div class="example"><pre>/65:    write(4, " 1 2 7 . 0 . 0 . 1   -  ".., 78)      = 78</pre></div>

    <p>Cet appel &#224; <code>write(2)</code> enregistre la requ&#234;te dans le journal
    des acc&#232;s. Notez qu'une des choses manquant &#224; cette trace est un appel &#224;
    <code>time(2)</code>. A la diff&#233;rence d'Apache 1.3, Apache 2.x utilise
    <code>gettimeofday(3)</code> pour consulter l'heure. Sur certains syst&#232;mes
    d'exploitation, comme Linux ou Solaris, <code>gettimeofday</code> est
    impl&#233;ment&#233; de mani&#232;re optimis&#233;e de telle sorte qu'il consomme moins de
    ressources qu'un appel syst&#232;me habituel.</p>

    <div class="example"><pre>/65:    shutdown(9, 1, 1)                               = 0
/65:    poll(0xFAF7B980, 1, 2000)                       = 1
/65:    read(9, 0xFAF7BC20, 512)                        = 0
/65:    close(9)                                        = 0</pre></div>

    <p>Le thread de worker effectue une fermeture "en prenant son temps"
    (lingering close) de la connexion.</p>

    <div class="example"><pre>/65:    close(10)                                       = 0
/65:    lwp_park(0x00000000, 0)         (sleeping...)</pre></div>

    <p>Enfin, le thread de worker ferme le fichier qu'il vient de d&#233;livrer et
    se bloque jusqu'&#224; ce que le thread en &#233;coute lui assigne une autre
    connexion.</p>

    <div class="example"><pre>/67:    accept(3, 0x001FEB74, 0x001FEB94, 1) (sleeping...)</pre></div>

    <p>Pendant ce temps, le thread &#224; l'&#233;coute peut accepter une autre connexion
    &#224; partir du moment o&#249; il a assign&#233; la connexion pr&#233;sente &#224; un thread de
    worker (selon une certaine logique de contr&#244;le de flux dans le MPM worker
    qui impose des limites au thread &#224; l'&#233;coute si tous les threads de worker
    sont occup&#233;s). Bien que cela n'apparaisse pas dans cette trace,
    l'<code>accept(2)</code> suivant peut (et le fait en g&#233;n&#233;ral, en situation
    de charge &#233;lev&#233;e) s'ex&#233;cuter en parall&#232;le avec le traitement de la
    connexion qui vient d'&#234;tre accept&#233;e par le thread de worker.</p>

  </div></div>
<div class="bottomlang">
<p><span>Langues Disponibles: </span><a href="../en/misc/perf-tuning.html" hreflang="en" rel="alternate" title="English">&nbsp;en&nbsp;</a> |
<a href="../fr/misc/perf-tuning.html" title="Fran&#231;ais">&nbsp;fr&nbsp;</a> |
<a href="../ko/misc/perf-tuning.html" hreflang="ko" rel="alternate" title="Korean">&nbsp;ko&nbsp;</a> |
<a href="../tr/misc/perf-tuning.html" hreflang="tr" rel="alternate" title="T&#252;rk&#231;e">&nbsp;tr&nbsp;</a></p>
</div><div class="top"><a href="#page-header"><img src="../images/up.gif" alt="top" /></a></div><div class="section"><h2><a id="comments_section" name="comments_section">Commentaires</a></h2><div class="warning"><strong>Notice:</strong><br />This is not a Q&amp;A section. Comments placed here should be pointed towards suggestions on improving the documentation or server, and may be removed again by our moderators if they are either implemented or considered invalid/off-topic. Questions on how to manage the Apache HTTP Server should be directed at either our IRC channel, #httpd, on Freenode, or sent to our <a href="http://httpd.apache.org/lists.html">mailing lists</a>.</div>
<script type="text/javascript"><!--//--><![CDATA[//><!--
var comments_shortname = 'httpd';
var comments_identifier = 'http://httpd.apache.org/docs/trunk/misc/perf-tuning.html';
(function(w, d) {
    if (w.location.hostname.toLowerCase() == "httpd.apache.org") {
        d.write('<div id="comments_thread"><\/div>');
        var s = d.createElement('script');
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://comments.apache.org/show_comments.lua?site=' + comments_shortname + '&page=' + comments_identifier;
        (d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0]).appendChild(s);
    }
    else {
        d.write('<div id="comments_thread">Comments are disabled for this page at the moment.<\/div>');
    }
})(window, document);
//--><!]]></script></div><div id="footer">
<p class="apache">Copyright 2018 The Apache Software Foundation.<br />Autoris&#233; sous <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.</p>
<p class="menu"><a href="../mod/">Modules</a> | <a href="../mod/quickreference.html">Directives</a> | <a href="http://wiki.apache.org/httpd/FAQ">FAQ</a> | <a href="../glossary.html">Glossaire</a> | <a href="../sitemap.html">Plan du site</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>